# TypeScript Style Guide

## 1 Вступ

Цей документ визначає вимоги до стилю кодування за допомогою TypeScript в корпоративному середовищі "Український процесинговий центр" (надалі Компанія).

Документ базовано на специфікації [Google Typescript Styleguide](https://google.github.io/styleguide/tsguide.html).

## 2 Основні вимоги до вихідного файлу

### 2.1 Кодування файлу

Вихідні файли мають бути закодовані в UTF-8.

#### 2.1.1 Пробільні символи

Окрім послідовності символів закінчення рядка, символ горизонтального пробілу ASCII (0x20) є єдиним пробілом, який з'являється будь-де у вихідному файлі. Це означає, що всі інші пробіли в рядкових літералах екрануються.

#### 2.1.2 Спеціальні ESCAPE послідовності

Для будь-якого символу, що має спеціальну керуючу послідовність ( \', \", \\, \b, \f, \n, \r, \t, \v), використовується ця послідовність, а не відповідна числова керуюча послідовність (наприклад \x0a, \u000a, або \u{a}). Застарілі вісімкові керуючі послідовності ніколи не використовуються.

#### 2.1.2 Символи, що не входять до ASCII

Для символів, що не належать до ASCII, використовується фактичний символ Unicode. Для недрукованих символів можна використовувати еквівалентні шістнадцяткові або Unicode-екрановані символи разом із пояснювальним коментарем.

## 3 Структура вихідного файлу

Вихідні файли складаються з наступних частин, у такому порядку:

1. Інформація про авторські права, якщо є
2. JSDoc з @fileoverview, якщо є
3. Імпорт відповідних модулів, якщо є
4. Реалізація файлу

**Рівно один порожній рядок** розділяє кожен присутній розділ.

### 3.1 Інформація про авторські права

Якщо у файлі потрібна інформація про ліцензію або авторські права, додайте її в `JSDoc` форматі на початку файлу.

### 3.2 Розділ @fileoverview

Файл може мати `@fileoverview` в форматі `JSDoc` верхнього рівня. Якщо він є, він може надавати опис вмісту файлу, його використання або інформацію про його залежності. Перенесені рядки не мають відступів.

Приклад:

```js
/**
 * @fileoverview Опис файлу. Текст, який описує вміст файлу.
 * Наступний або перенесений рядок опису.
 */
```

### 3.3 Імпорт модулів

Використовується чотири варіанти операторів імпорту:

- Імпорт модуля `import * as foo from '...';`
- Деструктурований імпорт `import { SomeThing } from '...';`
- Імпорт за замовченням `import SomeThing from '...';`
- Side-effect імпорт `import '...';`

Приклади:

```js
// Module import
import * as ng from "@angular/core";
// Destructuring import
import { Foo } from "./foo";

// Default import
import Button from "Button";

// Side effects:
import "jasmine";
import "@polymer/paper-button";
```

#### 3.3.1 Шляхи імпорту

Шляхи можуть бути відносними, тобто починатися з `.` або `..`, або мати кореневий каталог, наприклад, `root/path/to/file`.

Код повинен використовувати відносні шляхи імпорту, а не абсолютні, коли звертається до файлів в межах одного (логічного) проєкту, оскільки це дозволяє переміщувати проєкт без внесення змін до цих імпортів.

Приклади:

```js
import { Symbol1 } from "path/from/root";
import { Symbol2 } from "../parent/file";
import { Symbol3 } from "./sibling";
```

#### 3.3.2 Простір імен проти іменованого імпорту

Можна використовувати як імпорт простору імен, так і імпорт з іменами.

Надавайте перевагу іменованим імпортам для символів, які часто використовуються у файлі, або для символів, які мають зрозумілі назви, наприклад, Vitest's `describe` та `it`. Іменовані імпорти можна за потреби перетворювати на зрозуміліші назви за допомогою `as`.

Надавайте перевагу імпорту просторів імен, якщо використовується багато різних символів з великих API. Імпорт простору імен надає назву всім експортованим модулям, і кожен експортований символ з модуля стає властивістю імені модуля. Імпорт простору імен може покращити читабельність експортованих символів, які мають поширені назви, такі як `Model` або, `Controller` без необхідності оголошення псевдонімів.

Приклади:

Погано: overlong import statement of needlessly namespaced names.

```js
import {
  Item as TableviewItem,
  Header as TableviewHeader,
  Row as TableviewRow,
  Model as TableviewModel,
  Renderer as TableviewRenderer,
} from "./tableview";

let item: TableviewItem | undefined;
```

Краще: використовуйте модуль для простору імен.

```js
import * as tableview from "./tableview";

let item: tableview.Item | undefined;
```

Погано: назва модуля не покращує читабельність.

```js
import * as testing from "./testing";

testing.describe("foo", () => {
  testing.it("bar", () => {
    testing.expect(null).toBeNull();
    testing.expect(undefined).toBeUndefined();
  });
});
```

Краще: використовуйте деструктуризований імпорт для функцій.

```js
import { describe, it, expect } from "./testing";

describe("foo", () => {
  it("bar", () => {
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
  });
});
```

#### 3.3.3 Перейменування імпорту

Код має виправляти колізії імен, використовуючи імпорт простору імен або перейменовуючи самі експорти `import { SomeThing as SomeThingOther } from '...';`.

Коли перейменування може бути корисним:

- Якщо необхідно уникнути колізій з іншими імпортованими символами.
- Якщо ім'я імпортованого символу згенеровано.
- Якщо імпортуються символи, назви яких самі по собі незрозумілі, або мають дуже загальне іменування.

### 3.4 Експорт модулів, функцій, тощо

Використовуйте іменований експорт у всьому коді. Не використовуйте експорт за замовчуванням. Це гарантує, що весь імпорт буде дотримуватися єдиного шаблону.

Добре:

```js
export class Foo { ... }
export function Bar () { ... }
```

Погано:

```js
export default class Foo { ... }
```

Чому не слід використовувати експорт за замовчуванням? Експорт за замовчуванням не містить канонічної назви, що ускладнює централізоване обслуговування та дає відносно невелику користь власникам коду, зокрема потенційно знижує читабельність:

```js
import Foo from "./bar"; // Можливо.
import Bar from "./bar"; // Також можливо.
```

Іменований експорт має перевагу в тому, що може викликати помилки, коли оператори імпорту намагаються імпортувати щось, що не було оголошено.

#### 3.4.1 Видимість експорту

TypeScript не підтримує обмеження видимості експортованих символів. Експортуйте лише ті символи, які використовуються поза модулем. Зазвичай мінімізуйте експортовану API-поверхню модулів.

#### 3.4.2 Mutable експорт

Використання `export let ...` заборонено!

#### 3.4.3 Контейнерні класи

Не створюйте контейнерні класи зі статичними методами або властивостями заради простору імен. Натомість експортуйте окремі константи та функції:

Погано

```js
export class Container {
  static FOO = 1;
  static bar() {
    return 1;
  }
}
```

Добре

```js
export const FOO = 1;
export function bar() {
  return 1;
}
```

### 3.5 Імпорт та експорт типів

#### 3.5.1 Імпорт типів

Ви можете використовувати `import type {...}`, коли імпортований символ використовується лише як тип. Використовуйте звичайний імпорт для значень.

Компілятор TypeScript автоматично обробляє цю відмінність і не вставляє завантаження під час виконання для посилань на типи.

**Навіщо анотувати імпорт типів?**

Компілятор TypeScript може працювати у двох режимах:

- У режимі розробки нам зазвичай потрібні швидкі цикли ітерацій. Компілятор транспілює в JavaScript без повної інформації про тип. Це набагато швидше, але `import type` в певних випадках вимагає цього.
- У продакшн-режимі нам потрібна коректність. Тип компілятора перевіряє все та гарантує `import type` правильність використання.

Якщо вам потрібно примусово виконати завантаження під час виконання для побічних ефектів, використовуйте `import '...';`.

#### 3.5.2 Експорт типів

Використовуйте `export type` для ре-експорту типу.

```js
export type { AnInterface } from "./foo";
```

#### 3.5.3 Використання namespace

Використання namespace заборонено.

## 4 Мовні особливості

У цьому розділі визначено, які функції можна використовувати, а які ні, а також будь-які додаткові обмеження на їх використання.

Мовні особливості, які не обговорюються в цьому посібнику зі стилю, можуть використовуватися без рекомендацій щодо їх використання.

### 4.1 Оголошення локальних змінних

Завжди використовуйте `const` або `let` для оголошення змінних. Використовуйте `const` за замовченням, якщо якщо змінну не потрібно перепризначити.

Використання `var` заборонено.

Завжди використовуйте одну змінну для одній декларації. Використання `let a = 1, b = 2` заборонено.

#### 4.1.1 Іменування змінних

**Літеральні константи**

Для визначення літеральних констант використовується стиль SNAKE_UPPER_CASE.

```js
const END_POINT = "https://domain.com/api/endpoint";
```

**Константи**

**Змінні**

### 4.2 Масиви

#### 4.2.1 Array конструктор

Не використовуйте `Array()` конструктор з або без `new`. Його використання заплутане та суперечливе:

```js
const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Натомість завжди використовуйте дужкові позначення або метод `from` для ініціалізації масивів:

```js
const a = [2];
const b = [2, 3];

// Equivalent to Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from < number > { length: 5 }.fill(0);
```

#### 4.2.2 Визначення властивостей в масивах

Не визначайте та не використовуйте нечислові властивості масиву (окрім `length`).

#### 4.2.3 Використання spread

Використовуйте синтаксис розгортання [...foo]. Spread є зручним скороченням для поверхневого копіювання або об'єднання ітерабельних об'єктів.

```js
const foo = [1];

const foo2 = [...foo, 6, 7];

const foo3 = [5, ...foo];

foo2[1] === 6;
foo3[1] === 1;
```

Під час використання синтаксису розповсюдження значення, що розповсюджується, має відповідати тому, що створюється. Під час створення масиву розповсюджуйте лише ітерабельні об'єкти. Примітиви (включаючи null та undefined) не повинні розповсюджуватися.

#### 4.2.4 Деструктуризація масивів

Літерали масивів можуть використовуватися в лівій частині присвоєння для виконання деструктуризації (наприклад, під час розпакування кількох значень з одного масиву або ітерованого об'єкта). Може бути включений кінцевий елемент- залишок (без пробілу між ...та назвою змінної). Елементи слід пропускати, якщо вони не використовуються.

```js
const [a, b, c, ...rest] = generateResults();
let [, b, , d] = someArray;
```

Деструктуризацію також можна використовувати для параметрів функцій. Завжди вказуйте [] як значення за замовчуванням, якщо параметр деструктурованого масиву є необов'язковим, і вкажіть значення за замовчуванням ліворуч:

```js
function destructured([a = 4, b = 2] = []) { … }
```

**Заборонено:**

```js
function badDestructuring([a, b] = [4, 2]) { … }
```

Для (роз)пакування кількох значень у параметр або повернення функції, по можливості віддавайте перевагу деструктуризації об'єктів над деструктуризацією масивів, оскільки це дозволяє іменувати окремі елементи та вказувати різний тип для кожного.

### 4.3 Об'єктні літерали

#### 4.3.1 Object конструктор

Використання конструктора `Object()` заборонено. Натомість використовуйте об'єктний літерал `{}`

```js
const myObj1 = {};
const myObj2 = { a: 0, b: 1, c: 2 };
```

**Заборонено**

```js
const myObj = new Object();
```

#### 4.3.2 Ітерація об'єктів

Ітерація об'єктів за допомогою `for (... in ...)` схильна до помилок. Вона включатиме перелічувані властивості з ланцюжка прототипів.

Не використовуйте нефільтровані `for (... in ...)` твердження:

```js
for (const x in someObj) {
  // x може походити від якогось батьківського прототипу!
}
```

Або фільтруйте значення явно за допомогою оператора `if`, або використовуйте for `(... of Object.keys(...))`:

```js
for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // тепер x точно визначено в someObj
}
for (const x of Object.keys(someObj)) {
  // note: for _of_!
  // тепер x точно визначено в someObj
}
for (const [key, value] of Object.entries(someObj)) {
  // note: for _of_!
  // тепер key точно визначено в someObj
}
```

#### 4.3.3 Використання синтаксису spread з об'єктами

Використання spread синтаксису `{ ...bar }` – це зручне скорочення для створення поверхневої копії об'єкта. Під час використання spread синтаксису в ініціалізації об'єкта пізніші значення замінюють попередні значення з тим самим ключем.

```js
const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
};

foo2.num === 5;
foo3.num === 1;
```

Під час використання spread синтаксису значення, що розповсюджується, має відповідати тому, що створюється. Тобто, під час створення об'єкта можна розповсюджувати лише об'єкти. Масиви та примітиви (включаючи `null` та `undefined`) розповсюджуватися не повинні. Уникайте поширення об'єктів, які мають прототипи, відмінні від прототипу `Object` (наприклад, визначення класів, екземпляри класів, функції), оскільки така поведінка є неінтуїтивно зрозумілою (поверхнево копіюються лише перелічувані непрототипні властивості).

Погано:

```js
const foo = { num: 7 };
const bar = { num: 5, ...(shouldUseFoo && foo) }; // might be undefined

// Creates { 0: 'a', 1: 'b', 2: 'c' } but has no length
const fooStrings = ["a", "b", "c"];
const ids = { ...fooStrings };
```

Добре:

```js
const foo = shouldUseFoo ? { num: 7 } : {};
const bar = { num: 5, ...foo };
```

#### 4.3.4 Обчислені назви властивостей

Обчислювані назви властивостей (наприклад, `{['key' + foo()]: 42}`) дозволені та вважаються ключами у стилі словника (в лапках) (тобто не повинні змішуватися з ключами без лапок), якщо обчислювана властивість не є символом (наприклад, `[Symbol.iterator]`).

#### 4.3.5 Деструктуризація об'єктів

Шаблони деструктуризації об'єктів можуть використовуватися в лівій частині присвоєння для виконання деструктуризації та розпакування кількох значень з одного об'єкта.

Деструктуровані об'єкти також можуть використовуватися як параметри функцій, але їх слід максимально спростити: один рівень скорочених властивостей без лапок. Глибші рівні вкладеності та обчислювані властивості не можуть використовуватися при деструктуризації параметрів. Вкажіть будь-які значення за замовчуванням у лівій частині деструктурованого параметра (`{str = 'some default'} = {}`, а не `{str} = {str: 'some default'}`), і якщо деструктурований об'єкт сам по собі є необов'язковим, він має мати значення за замовчуванням `{}`.

Правильне використання:

```js
interface Options {
  /** The number of times to do something. */
  num?: number;

  /** A string to do stuff to. */
  str?: string;
}

function destructured({ num, str = "default" }: Options = {}) {}
```

**Заборонено:**

```js
function nestedTooDeeply({ x: { num, str } }: { x: Options }) {}
function nontrivialDefault(
  { num, str }: Options = { num: 42, str: "default" }
) {}
```

### 4.4 Класи

#### 4.4.1 Декларація класів

Оголошення класів не повинні завершуватися крапкою з комою.

Правильно:

```js
class Foo {}
```

Не правильно:

```js
class Foo {} // Непотрібна крапка з комою
```

Натомість, оператори, що містять вирази класу, повинні завершуватися крапкою з комою:

```js
export const Baz = class extends Bar {
  method(): number {
    return this.x;
  }
}; // Крапка з комою тут, оскільки це statement, а не декларація
```

Не рекомендується і не заохочується використовувати порожні рядки, що відокремлюють фігурні дужки оголошення класу від іншого вмісту класу:

```js
// No spaces around braces - fine.
class Baz {
  method(): number {
    return this.x;
  }
}

// Spaces around braces - bad.
class Foo {
  method(): number {
    return this.x;
  }
}
```

#### 4.4.2 Декларація методів класу

В оголошеннях методів класу не можна використовувати крапку з комою для розділення окремих оголошень методів.

Оголошення методів слід відокремлювати від навколишнього коду одним порожнім рядком:

```js
class Foo {
  doThing() {
    console.log("A");
  }

  getOtherThing(): number {
    return 4;
  }
}
```

#### 4.4.3 Статичні методи

**Уникайте приватних статичних методів!**. Там, де це не заважає читабельності, віддавайте перевагу локальним для модуля функціям над приватними статичними методами.

**Не покладайтеся на динамічну диспетчеризацію!**. Код не повинен покладатися на динамічну диспетчеризацію статичних методів. Статичні методи слід викликати лише для самого базового класу (який його безпосередньо визначає). Статичні методи не слід викликати для змінних, що містять динамічний екземпляр, який може бути або конструктором, або конструктором підкласу (і в такому разі їх необхідно визначити за допомогою `@nocollapse`), і не повинен викликатися безпосередньо у підкласі, який не визначає сам метод.

Заборонено:

```js
// Контекст для наведених нижче прикладів (цей клас сам по собі цілком прийнятний)
class Base {
  /** @nocollapse */ static foo() {}
}
class Sub extends Base {}

// Не рекомендується викликати статичні методи динамічно
function callFoo(cls: typeof Base) {
  cls.foo();
}

// Заборонено викликати статичні методи для підкласів, які самі їх не визначають
Sub.foo();

// Заборонено: не звертайтеся до this в статичних методах.
class MyClass {
  static foo() {
    return this.staticField;
  }
}
MyClass.staticField = 1;
```

**Уникайте static `this` references!**. Код не повинен використовувати `this` у статичному контексті.

```js
class ShoeStore {
  static storage: Storage = ...;

  static isAvailable(s: Shoe) {
    // Погано: не використовуйте `this` у статичному методі.
    return this.storage.has(s.id);
  }
}

class EmptyShoeStore extends ShoeStore {
  static storage: Storage = EMPTY_STORE;  // замінює сховище з ShoeStore
}
```

#### 4.4.4 Конструктори

Виклики конструктора повинні використовувати дужки, навіть якщо не передаються аргументи:

```js
const x = new Foo();
```

Немає потреби надавати порожній конструктор або такий, що просто делегує завдання у свій батьківський клас, оскільки ES2015 надає конструктор класу за замовчуванням, якщо такий не вказано. Однак конструктори з властивостями параметрів, модифікаторами видимості або декораторами параметрів не слід пропускати, навіть якщо тіло конструктора порожнє.

```js
class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

Конструктор має бути відокремлений від навколишнього коду як зверху, так і знизу одним порожнім рядком:

```js
class Foo {
  myField = 10;

  constructor(private readonly ctorParam) {}

  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

#### 4.4.5 Члени класу

Не використовуйте приватні поля (також відомі як приватні ідентифікатори, починаються з `#`). Замість цього використовуйте анотації видимості TypeScript:

Правильно:

```js
class Clazz {
  private ident = 1;
}
```

Заборонено:

```js
class Clazz {
  #ident = 1;
}
```

Позначте властивості, які ніколи не перепризначаються поза конструктором, модифікатором `readonly`. Якщо член класу не є параметром, ініціалізуйте його там, де він оголошений, що іноді дозволяє повністю видалити конструктор.

```js
class Foo {
  private readonly userList: string[] = [];
}
```

Замість того, щоб пропускати очевидний ініціалізатор до члена класу, використовуйте властивість параметра TypeScript.

```js
class Foo {
  constructor(private readonly barService: BarService) {}
}
```

**Геттери та сетери**

Для членів класу можна використовувати геттери та сетери, також відомі як аксесори. Метод геттера має бути чистою функцією (тобто результат має бути узгодженим і не мати побічних ефектів: геттери не повинні змінювати спостережуваний стан). Вони також корисні як засіб обмеження видимості внутрішніх або детальних деталей реалізації.

```js
class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

Заборонено:

```js
class Foo {
  nextId = 0;
  get next() {
    return this.nextId++; // Геттер змінює спостережуваний стан
  }
}
```

Якщо для приховування властивості класу використовується аксессор, властивість може мати префікс або суфікс будь-якого цілого слова, наприклад, `internal` або `wrapped`. Під час використання цих приватних властивостей, звертайтеся до значення через аксессор, коли це можливо. Принаймні один метод доступу для властивості має бути нетривіальним: не визначайте наскрізні методи доступу лише з метою приховування властивості. Натомість зробіть властивість публічною (або подумайте про те, щоб зробити його лише для читання, а не просто визначати метод отримання без методу встановлення).

```js
class Foo {
  isVisible = true;
  private wrappedBar = '';

  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

Геттери та сетери не можна визначати за допомогою `Object.defineProperty`, оскільки це заважає перейменуванню властивостей.

**Обчислювані властивості**

Обчислювані властивості можна використовувати в класах лише тоді, коли властивість є символом. Властивості в стилі Dict (тобто взяті в лапки або обчислені несимвольні ключі) не допускаються. Для будь-яких логічно ітерованих класів слід визначити метод `[Symbol.iterator]`. Будьте обережні з використанням будь-яких інших вбудованих символів (наприклад, `Symbol.isConcatSpreadable`), оскільки вони не поліфілюються компілятором і тому не працюватимуть у старіших браузерах.

#### 4.4.6 Видимість

Обмеження видимості властивостей, методів та цілих типів допомагає зберегти роз'єднаність коду.

Для визначення видимістю керуйтеся наступними правилами:

- Обмежте видимість символу якомога більше.
- Розгляньте можливість перетворення приватних методів на не експортовані функції в межах того самого файлу, але поза межами будь-якого класу, та переміщення приватних властивостей в окремий не експортований клас.
- Символи TypeScript за замовчуванням є публічними. Ніколи не використовуйте модифікатор public, окрім випадків оголошення властивостей параметрів public, які не призначені лише для читання (у конструкторах).

```js
class Foo {
  bar = new Bar();  // публічний модифікатор не потрібен

  constructor(public baz: Baz) {}  // дозволено публічний модифікатор
}
```

#### 4.4.7 Заборонені паттерни класів

Не маніпулюйте прототипами безпосередньо. Ключове слово class дозволяє чіткіше та зрозуміліше визначити класи, ніж визначення властивостей прототипу. Звичайний код реалізації не має права маніпулювати цими об'єктами. Міксини та модифікація прототипів вбудованих об'єктів явно заборонені.

**Виняток:** Код фреймворку може потребувати використання прототипів, і не повинен вдаватися до ще гірших обхідних шляхів, щоб уникнути цього.

### 4.5 Функції

#### 4.5.1 Термінологія

Існує багато різних типів функцій з тонкими відмінностями між ними. У цьому посібнику використовується наступна термінологія:

- _function declaration_: оголошення (тобто не вираз) з використанням ключового слова `function`
- _function expression_: вираз, який зазвичай використовується при присвоєнні або передається як параметр за допомогою ключового слова `function`
- _arrow function_: вираз, що використовує синтаксис `=>`
- _block body_: права частина стрілкової функції з фігурними дужками
- _concise body_: права частина стрілкової функції без фігурних дужок

Методи та класи/конструктори не розглядаються в цьому розділі.

#### 4.5.2 Надавати перевагу оголошенням функцій для іменованих функцій

Під час визначення іменованих функцій надавайте перевагу оголошенням функцій над стрілковими функціями або функціональними виразами.

```js
function foo() {
  return 42;
}
```

Стрілкові функції можна використовувати, наприклад, коли потрібна явна анотація типу.

```js
interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) => { ... };
```

#### 4.5.3 Вкладені функції

Функції, вкладені в інші методи або функції, можуть використовувати оголошення функцій або стрілкові функції, залежно від обставин. Зокрема, в тілах методів стрілкові функції є кращими, оскільки вони мають доступ до зовнішнього `this`.

Не використовуйте функціональні вирази. Використовуйте замість цього стрілкові функції.

Правильно:

```js
bar(() => {
  this.doSomething();
});
```

Заборонено:

```js
bar(function() { ... })
```

Виняток: Функціональні вирази можна використовувати лише якщо код має динамічно переприв'язувати `this` (але це не рекомендується), або для функцій-генераторів (які не мають синтаксису стрілок).

#### 4.5.5 Тіла стрілочних функцій

Використовуйте стрілкові функції з лаконічними тілами (тобто виразами) або блочними тілами, залежно від обставин.

```js
// Top level functions use function declarations.
function someFunction() {
  // Block bodies are fine:
  const receipts = books.map((b: Book) => {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Concise bodies are fine, too, if the return value is used:
  const longThings = myValues
    .filter((v) => v.length > 1000)
    .map((v) => String(v));

  function payMoney(amount: number) {
    // function declarations are fine, but must not access `this`.
  }

  // Nested arrow functions may be assigned to a const.
  const computeTax = (amount: number) => amount * 0.12;
}
```

Використовуйте `concise body` лише тоді, коли повернене значення функції фактично використовується. `block body` гарантує, що тип повернення буде недійсним, і запобігає потенційним побічним ефектам.

```js
// GOOD: return value is unused, use a block body.
myPromise.then((v) => {
  console.log(v);
});

// GOOD: code may use blocks for readability.
const transformed = [1, 2, 3].map((v) => {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});

// GOOD: explicit `void` ensures no leaked return value
myPromise.then((v) => void console.log(v));
```

Оператор `void` можна використовувати, щоб гарантувати, що стрілочна функція з тілом виразу поверне значення `undefined`, коли результат не використовується.

#### 4.5.6 Перевизначення this

Функціональні вирази та оголошення функцій не повинні використовувати `this`, якщо вони спеціально не існують для повторного зв'язування вказівника `this`. Повторного зв'язування `this` у більшості випадків можна уникнути, використовуючи стрілкові функції або явні параметри.

Правильно:

```js
// Good: explicitly reference the object from an arrow function.
document.body.onclick = () => {
  document.body.textContent = "hello";
};

// Alternatively: take an explicit parameter
const setTextFn = (e: HTMLElement) => {
  e.textContent = "hello";
};
document.body.onclick = setTextFn.bind(null, document.body);
```

Не правильно:

```js
function clickHandler() {
  // Bad: what's `this` in this context?
  this.textContent = "Hello";
}

// Bad: the `this` pointer reference is implicitly set to document.body.
document.body.onclick = clickHandler;
```

Надавайте перевагу стрілковим функціям над іншими підходами до зв'язування `this`, такими як `f.bind(this)` або `const self = this`.

#### 4.5.7 Надавати перевагу передачі стрілкових функцій як зворотних викликів

Зворотні виклики можуть бути викликані з неочікуваними аргументами, які можуть пройти перевірку типу, але все одно призвести до логічних помилок.

Уникайте передачі іменованого зворотного виклику до функції вищого порядку, якщо ви не впевнені у стабільності сигнатур викликів обох функцій. Зокрема, остерігайтеся рідше використовуваних необов'язкових параметрів.

```js
// BAD: Arguments are not explicitly passed, leading to unintended behavior
// when the optional `radix` argument gets the array indices 0, 1, and 2.
const numbers = ["11", "5", "10"].map(parseInt);
// > [11, NaN, 2];
```

Натомість, надайте перевагу передачі стрілкової функції, яка явно пересилає параметри до іменованого зворотного виклику.

```js
// GOOD: Arguments are explicitly passed to the callback
const numbers = ["11", "5", "3"].map((n) => parseInt(n));
// > [11, 5, 3]

// GOOD: Function is locally defined and is designed to be used as a callback
function dayFilter(element: string | null | undefined) {
  return element != null && element.endsWith("day");
}

const days = ["tuesday", undefined, "juice", "wednesday"].filter(dayFilter);
```

#### 4.5.8 Стрілочні функції як властивості

Класи зазвичай не повинні містити властивостей, ініціалізованих стрілковими функціями. Властивості стрілочної функції вимагають, щоб викликаюча функція розуміла, що `this` викликаного об'єкта вже зв'язаний, що збільшує плутанину щодо того, що таке `this`, а об'єкти викликів та посилання, що використовують такі обробники, виглядають непрацюючими.

```js
// Явно керуйте `this` під час виклику.
class DelayHandler {
  constructor() {
    // Використовуйте анонімні функції, якщо можливо.
    setTimeout(() => {
      this.patienceTracker();
    }, 5000);
  }

  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

#### 4.5.9 Обробники подій

Обробники подій можуть використовувати стрілкові функції, коли немає потреби видаляти обробник (наприклад, якщо подію генерує сам клас). Якщо обробник вимагає видалення, властивості стрілкових функцій є правильним підходом, оскільки вони автоматично фіксують це та забезпечують стабільне посилання на видалення.

```js
// Обробники подій можуть бути анонімними функціями або властивостями стрілкових функцій.
class Component {
  onAttached() {
    // Подія генерується цим класом, видаляти його не потрібно.
    this.addEventListener('click', () => {
      this.listener();
    });

    // this.listener — це стабільне посилання, ми можемо видалити його пізніше.
    window.addEventListener('onbeforeunload', this.listener);
  }

  onDetached() {
    // Подія генерується window. Якщо ми не видалимо, this.listener
    // збереже посилання на `this`, оскільки воно прив'язане, що спричинить витік пам'яті.
    window.removeEventListener('onbeforeunload', this.listener);
  }

  // Стрілочна функція, що зберігається у властивості, автоматично прив'язується до `this`.
  private listener = () => {
    confirm('Do you want to exit the page?');
  }
}
```

Не використовуйте `bind` у виразі, який встановлює обробник подій, оскільки це створює тимчасове посилання, яке не можна видалити.

Не правильно

```js
// Слухачі зв'язування створюють тимчасове посилання, яке запобігає видаленню.
class Component {
  onAttached() {
    // Це створює тимчасове посилання, яке ми не зможемо видалити
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }

  onDetached() {
    // Це зв'язування створює інше посилання, тому цей рядок нічого не робить.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }

  private listener() {
    confirm('Do you want to exit the page?');
  }
}
```

#### 4.5.10 Ініціалізатори параметрів

Необов'язковим параметрам функції може бути надано ініціалізатор за замовчуванням, який використовуватиметься, коли аргумент пропущено. Ініціалізатори не повинні мати жодних помітних побічних ефектів. Ініціалізатори повинні бути якомога простішими.

```js
function process(name: string, extraContext: string[] = []) {}
function activate(index = 0) {}
```

Не правильно:

```js
// ПОГАНО: побічний ефект збільшення лічильника
let globalCounter = 0;
function newId(index = globalCounter++) {}

// Погано: розкриває спільний змінний стан, що може призвести до ненавмисного зв'язку
// між викликами функцій
class Foo {
  private readonly defaultPaths: string[];
  frobnicate(paths = defaultPaths) {}
}
```

Використовуйте параметри за замовчуванням економно. Надавайте перевагу деструктуризації для створення читабельних API, коли є більше, ніж невелика кількість необов'язкових параметрів, які не мають природного порядку.

#### 4.5.11 Надавайте перевагу rest та spread, коли це доречно

Використовуйте параметр-залишок замість доступу `arguments`. Ніколи не давайте назву локальній змінній або параметру `arguments`, оскільки це може призвести до плутанини з вбудованою назвою.

```js
function variadic(array: string[], ...numbers: number[]) {}
```

Використовуйте синтаксис розгортання (spread) замість `Function.prototype.apply`.

#### 4.5.12 Форматування функцій

Порожні рядки на початку або в кінці тіла функції не допускаються.

Один порожній рядок може використовуватися в тілах функцій економно для створення логічних груп операторів.

Генератори повинні додавати `*` до ключових слів `function` та `yield`, як у `function* foo()` та `yield* iter`, а не ~~`function *foo()`~~ або ~~`yield *iter`~~.

Дужки навколо лівої частини стрілкової функції з одним аргументом рекомендуються, але не обов'язкові.

Не ставте пробіл після ... у синтаксисі rest або spread.

```js
function myFunction(...elements: number[]) {}

myFunction(...array, ...iterable, ...generator());
```

### 4.6 this

Використовуйте `this` лише в конструкторах та методах класів, функціях, у яких явно оголошено тип this (наприклад, function func(this: ThisType, ...)), або у стрілкових функціях, визначених в області видимості, де це може бути використано.

Ніколи не використовуйте `this` для посилання на глобальний об'єкт, контекст `eval` або ціль події.

### 4.7 Інтерфейси

Використовуйте відповідно до поточних потреб та синтаксису.

### 4.8 Примітивні літерали

#### 4.8.1 Строкові літерали

Звичайні рядкові літерали розділяються одинарними лапками `'Lorem ipsum'`. Якщо рядок містить символ одинарної лапки, розгляньте можливість використання шаблонного рядка, щоб уникнути необхідності екранувати лапку.

```js
const API_ENDPOINT = "https://domain.com/api/v1";
```

Не використовуйте продовження рядка (тобто завершення рядка всередині рядкового літерала зворотною скісну рискою) ні в звичайних, ні в шаблонних рядкових літералах.

Заборонено:

```js
const LONG_STRING =
  "This is a very very very very very very very long string. \
    It inadvertently contains long stretches of spaces due to how the \
    continued lines are indented.";
```

Правильно:

```js
const LONG_STRING =
  "This is a very very very very very very long string. " +
  "It does not contain long stretches of spaces because it uses " +
  "concatenated strings.";
```

Використовуйте шаблонні літерали (розділені символом ` зворотня лапка) замість складного об'єднання рядків, особливо якщо задіяно кілька рядкових літералів. Шаблонні літерали можуть охоплювати кілька рядків.

Якщо літерал шаблону охоплює кілька рядків, він не обов'язково повинен слідувати за відступом блоку, що його оточує, хоча може, якщо додані пробіли не мають значення.

```js
function arithmetic(a: number, b: number) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
```

#### 4.8.2 Числові літерали

Числа можна вказувати у десятковому, шістнадцятковому, вісімковому або двійковому форматах. Використовуйте префікси `0x`, `0o` та `0b` з малими літерами відповідно для шістнадцяткового, вісімкового та двійкового форматів.

Ніколи не ставте початковий нуль, якщо за ним одразу не йде `x`, `o` або `b`.

#### 4.8.3 Приведення типів

Код TypeScript може використовувати функції `String()`, `Number()`, та `Boolean()` (примітка: без оператора `new`!), літерали шаблонів рядків або `!!` для приведення типів.

```js
const bool = Boolean(false);
const str = String(aNumber);
const num = Number(aString);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Значення перелічуваних типів - enum (включаючи об'єднання перелічуваних типів та інших типів) не повинні перетворюватися на логічні значення за допомогою `Boolean()` або `!!`, а натомість повинні порівнюватися явно за допомогою операторів порівняння.

```js
enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = level !== SupportLevel.NONE;

const maybeLevel: SupportLevel|undefined = ...;
enabled = level !== undefined && level !== SupportLevel.NONE;
```

Використання конкатенації рядків для приведення до рядка не рекомендується, оскільки ми перевіряємо, чи операнди оператора plus мають однакові типи.

Код повинен використовувати `Number()` для розбору числових значень і повинен явно перевіряти повернення значень `NaN`, окрім випадків, коли неможливість розбору є неможливою з контексту.

```js
const aNumber = Number('123');
if (!isFinite(aNumber)) throw new Error(...);
```

У коді не можна використовувати унарний плюс `+` для перетворення рядків на числа. Розбір чисел може призвести до невдачі, мати несподівані кутові випадки. З огляду на це, унарний плюс дуже легко пропустити під час перевірки коду.

Слід з обережністю використовувати, або взагалі відмовитись від використання `parseInt` або `parseFloat` для розбору чисел, за винятком рядків, що не є десятковими. Обидві ці функції ігнорують завершальні символи в рядку, що може призвести до помилок (наприклад, розбір `12 гномів` як `12`).

```js
if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);

const n = parseInt(someString, 16);  // Only allowed for radix != 10
```

Замість `parseInt`, використовуйте `Number()`, а потім `Math.floor` або `Math.trunc`, щоб розібрати цілочисельні числа:

```js
let f = Number(someString);
if (Number.isNaN(f)) handleError();
f = Math.floor(f);
```

Для перевірки, на `NaN` слід використовувати:

- `isNaN()` - коли попередньо не було використано приведення за допомогою `Number()`
- `Number.isNaN()` - коли значення вже приведено до числа за допомогою `Number()`

Різницю між `isNaN()` та `Number.isNaN()` дивись в специфікації ECAMScript.

Не використовуйте явні логічні перетворення в умовних виразах, які мають неявне логічне перетворення. Це умови в операторах `if`, `for` та `while`.

Заборонено:

```js
const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

### 4.9 Оператори потоку керування

Оператори потоку керування (`if`, `else`, `for`, `do`, `while` тощо) завжди використовують блоки у фігурних дужках для коду, що містить їх, навіть якщо тіло блоку містить лише один оператор. Перший оператор непорожнього блоку повинен починатися з окремого рядка.

```js
for (let i = 0; i < x; i++) {
  doSomethingWith(i);
}

if (x) {
  doSomethingWithALongMethodNameThatForcesANewLine(x);
}
```

Виняток: оператори `if`, що поміщаються в один рядок, можуть опускати блок.

```js
if (x) x.doFoo();
```

#### 4.9.1 Присвоєння в керуючих операторах

Намагайтеся уникати присвоєння змінних всередині керуючих операторів. Присвоєння можна легко сплутати з перевіркою рівності всередині керуючих операторів.

У випадках, коли присвоєння всередині керуючого оператора є кращим, візьміть присвоєння в додаткові дужки, щоб вказати, що воно навмисне.

```js
while ((x = someFunction())) {
  // Double parenthesis shows assignment is intentional
  // ...
}
```

#### 4.9.2 Ітерируємі контейнери

Використовуйте `for (... of comeArray)` для ітерації по масивах, `Array.prototype.forEach` та vanilla `for` з використанням індексів.

```js
for (const x of someArr) {
  // x is a value of someArr.
}

for (let i = 0; i < someArr.length; i++) {
  // Явно підраховуйте, якщо потрібен індекс, інакше використовуйте форму for/of.
  const x = someArr[i];
  // ...
}

for (const [i, x] of someArr.entries()) {
  // Альтернативний варіант вищезазначеного.
}
```

Цикли `for-in` можна використовувати лише для об'єктів у стилі `dict`. Не використовуйте `for (... in ...)` для ітерації по масивах, оскільки це контрінтуїтивно поверне індекси масиву (як рядки!), а не значення.

`Object.prototype.hasOwnProperty` слід використовувати в циклах `for-in`, щоб виключити небажані властивості прототипів. По можливості віддавайте перевагу `for-of` з `Object.keys`, `Object.values` ​​або `Object.entries`, а не `for-in`.

```js
for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  doWork(key, obj[key]);
}

for (const key of Object.keys(obj)) {
  doWork(key, obj[key]);
}

for (const value of Object.values(obj)) {
  doWorkValOnly(value);
}

for (const [key, value] of Object.entries(obj)) {
  doWork(key, value);
}
```

#### 4.9.3 Групування дужок

Необов'язкові групові дужки опускаються лише тоді, коли автор і рецензент погоджуються, що немає жодної розумної ймовірності того, що код буде неправильно інтерпретовано без них, і вони не зробили б код легшим для читання.

Не використовуйте зайві дужки навколо всього виразу після `delete`, `typeof`, `void`, `return`, `throw`, `case`, `in`, `of` або `yield`.

#### 4.9.4 Обробка Exceptions

Exception повинні використовуватися щоразу, коли виникають виняткові випадки.

Користувацькі exceptions слід визначати та використовувати скрізь, де власного типу `Error` недостатньо.

Надавайте перевагу викиданню exception над спеціальними підходами до обробки помилок (такими як передача типу посилання на контейнер помилок або повернення об'єкта з властивістю помилки).

Завжди використовуйте `new Error()` під час створення екземплярів exception, а не просто викликайте `Error()`. Обидві форми створюють новий екземпляр `Error`, але використання `new` більше узгоджується з тим, як створюються екземпляри інших об'єктів.

```js
throw new Error("Foo is not a valid bar.");
```

Під час перехоплення помилок код повинен припускати, що всі викинуті помилки є екземплярами `Error`.

```js
function assertIsError(e: unknown): asserts e is Error {
  if (!(e instanceof Error)) throw new Error("e is not an Error");
}

try {
  doSomething();
} catch (e: unknown) {
  // All thrown errors must be Error subtypes. Do not handle
  // other possible values unless you know they are thrown.
  assertIsError(e);
  displayError(e.message);
  // or rethrow:
  throw e;
}
```

В рідких випадках допускається нічого не робити у відповідь на перехоплений виняток.

#### 4.9.5 Switch

Усі оператори `switch` повинні містити групу операторів за замовчуванням, навіть якщо вона не містить коду. Група операторів за замовчуванням має бути останньою.

```js
switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
  // nothing to do.
}
```

Кожен switch блок має перериватися з використанням `break`, `return` або exception.

```js
switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // nothing to do.
}
```

#### 4.9.6 Перевірка рівності

Завжди використовуйте потрійне дорівнювання `===`, або не дорівнювання `!==`.

```js
if (foo === "bar" || baz !== bam) {
  // All good here.
}
```

Виняток: Порівняння з літеральним значенням `null` може використовувати оператори `==` та `!=` для порівняння як `null`, так і `undefined` значень.

```js
if (foo == null) {
  // Will trigger when foo is null or undefined.
}
```

#### 4.9.7 Type and non-nullability assertions

Твердження типу `x as SomeType` та твердження про неможливість значення null `y!` є небезпечними. Обидва лише вимикають компілятор TypeScript, але не вставляють жодних перевірок під час виконання для відповідності цим твердженням, тому вони можуть призвести до аварійного завершення роботи програми під час виконання.

Через це не слід використовувати твердження про типи та неможливість значення null без очевидної або явної причини для цього.

Коли ви хочете стверджувати тип або неможливість значення null, найкращою відповіддю є явно написати перевірку під час виконання, яка виконує цю перевірку.

```js
if (x instanceof Foo) {
  x.foo();
}

if (y) {
  y.bar();
}
```

Використовуйте анотації типу `:Foo` замість тверджень типу `as Foo` для визначення типу літерала об'єкта.

```js
interface Foo {
  bar: number;
  baz?: string;
}

const foo: Foo = {
  bar: 123,
  bam: "abc", // complains about "bam" not being defined on Foo.
};

function func(): Foo {
  return {
    bar: 123,
    bam: "abc", // complains about "bam" not being defined on Foo.
  };
}
```

#### 4.9.8 Обмеження кількості коду в блоці try

Обмежте кількість коду всередині блоку `try`, якщо це можна зробити без шкоди для читабельності.

Не правильно:

```js
try {
  const result = methodThatMayThrow();
  use(result);
} catch (error: unknown) {
  // ...
}
```

Правильно:

```js
let result;
try {
  result = methodThatMayThrow();
} catch (error: unknown) {
  // ...
}
use(result);
```

**Виняток**: Якщо блоки `try` знаходяться всередині циклу, можуть виникнути проблеми з продуктивністю. Розширення блоків `try` для охоплення всього циклу є прийнятним.

### 4.10 Декоратори

Декоратори мають синтаксис із префіксом `@`, наприклад, `@MyDecorator`.

Під час використання декораторів, декоратор повинен безпосередньо передувати символу, який він декорує, без порожніх рядків між ними:

```js
/** JSDoc comments go before decorators */
@Component({...})  // Note: no empty line after the decorator.
class MyComp {
  @Input() myField: string;  // Decorators on fields may be on the same line...

  @Input()
  myOtherField: string;  // ... or wrap.
}
```

### 4.11 Заборонені функції

#### 4.11.1 Об'єкти-обгортки для примітивних типів

Код TypeScript не повинен створювати екземпляри класів-обгорток для примітивних типів `String`, `Boolean` та `Number`. Класи-обгортки мають дивну поведінку, таку як `new Boolean(false)` при обчисленні значення `true`.

Заборонено:

```js
const s = new String("hello");
const b = new Boolean(false);
const n = new Number(5);
```

Обгортки можна викликати як функції для приведення змінних (що краще, ніж використання + або об'єднання порожнього рядка) або створення символів.

```js
const str = String(123);
const num = Number("123");
```

#### 4.11.2 Автоматична вставка крапки з комою

Не покладайтеся на автоматичну вставку крапки з комою (ASI). Явно завершуйте всі оператори крапкою з комою. Це запобігає помилкам через неправильну вставку крапки з комою та забезпечує сумісність з інструментами з обмеженою підтримкою ASI.

#### 4.11.3 Const enums

У коді не повинно використовуватися `const enum`, натомість використовуйте звичайний `enum`.

```js
enum ABC {
  A: 1,
  B: 2,
  C: 3,
}
```

`enum` TypeScript вже не можна змінювати; `const enum` — це окрема функція мови, пов'язана з оптимізацією, яка робить `enum` невидимим для користувачів JavaScript модуля.

#### 4.11.4 Оператори налагодження

Оператори налагодження не повинні бути включені до виробничого коду.

Заборонено в продакшен:

```js
function debugMe() {
  debugger;
}
```

#### 4.11.5 with

Заборонено використання оператора `with`! Його використання робить код біль незрозумілим і заборонений в `strict mode` ES5.

#### 4.11.6 Динамічне виконання коду

Не використовуйте `eval` або конструктор `Function(...string)` (за винятком завантажувачів коду). Ці функції потенційно небезпечні та просто не працюють у середовищах, що використовують суворі політики безпеки контенту.

#### 4.11.7 Нестандартні функції

Заборонено використовування нестандартних функцій ECMAScript або веб-платформи без окремого узгодження.

#### 4.11.8 Модифікація вбудованих об'єктів

Ніколи не змінюйте вбудовані типи, ні додаючи методи до їхніх конструкторів, ні до їхніх прототипів. Уникайте залежності від бібліотек, які роблять це.

Не додавайте символи до глобального об'єкта, окрім випадків абсолютної необхідності (наприклад, якщо цього вимагає сторонній API).

## 5 Іменування

### 5.1 Ідентифікатори

Ідентифікатори повинні використовувати лише літери ASCII, цифри, символи підкреслення (для констант та структурованих назв методів тестування) та (рідко) знак '$'.

#### 5.1.1 Стиль найменування

TypeScript виражає інформацію в типах, тому імена не повинні бути прикрашені інформацією, яка міститься в типі.

Деякі конкретні приклади цього правила:

- Не використовуйте кінцеві або початкові символи підкреслення для приватних властивостей або методів.
- Не використовуйте префікс opt\_ для необов'язкових параметрів.
- Не позначайте інтерфейси спеціально (IMyInterface або MyFooInterface), окрім випадків, коли це ідіоматично у своєму середовищі. Під час введення інтерфейсу для класу, дайте йому ім'я, яке виражає, чому інтерфейс взагалі існує (наприклад, клас TodoItem та інтерфейс TodoItemStorage, якщо інтерфейс виражає формат, який використовується для зберігання/серіалізації в JSON).

### 5.2 Правила за типом ідентифікатора

Більшість імен ідентифікаторів повинні відповідати регістру літер, зазначеному в таблиці нижче, залежно від типу ідентифікатора.

| Style            | Category                                                                                                               |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `UpperCamelCase` | class / interface / type / enum / decorator / type parameters / component functions in TSX / JSXElement type parameter |
| `lowerCamelCase` | variable / parameter / function / method / property / module alias                                                     |
| `CONSTANT_CASE`  | global constant values, including enum values. See [Constants](#identifiers-constants) below.                          |
| `#ident`         | private identifiers are never used.                                                                                    |

#### 5.2.1 Параметри типу

Type parameters, like in `Array<T>`, may use a single upper case character `T` or `UpperCamelCase`.

#### 5.2.2 Найменування тестів

Назви тестів мають відповідати формату `name.test.ts`. Де `name` визначає назву класу, методу, функції, тощо.

#### 5.2.3 `_` (underscore) префікс/суфікс

Ідентифікатори не повинні використовувати _ як префікс або суфікс. Це також означає, що _ не можна використовувати як самостійний ідентифікатор (наприклад, для позначення того, що параметр не використовується).

Не правильно:

```js
const [a, _, b] = [1, 5, 10];
```

Правильно:

```js
const [a, , b] = [1, 5, 10];
```

#### 5.2.4 Імпорти

Імпорт простору імен модулів має відповідати `lowerCamelCamelCase`, тоді як файли мають `snake_case`.

```js
import * as fooBar from "./foo_bar";
```

#### 5.2.5 Константи

`CONSTANT_CASE` (UPPER_SNAKE_CASE) вказує на те, що значення не повинно змінюватися, і може використовуватися для значень, які технічно можна змінити (тобто значень, які не є глибоко замороженими), щоб вказати користувачам, що їх не можна змінювати.

```js
const UNIT_SUFFIXES = {
  milliseconds: "ms",
  seconds: "s",
};
```

Константа також може бути статичною властивістю класу лише для читання.

```js
class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
```

Якщо значення може бути створене більше одного разу протягом життя програми (наприклад, локальна змінна, оголошена всередині функції, або статичне поле класу, вкладеного у функцію), тоді воно повинно використовувати `lowerCamelCase`.

Якщо значення є стрілковою функцією, яка реалізує інтерфейс, тоді його можна оголосити як `lowerCamelCase`.

#### 5.2.6 Псевдоніми

Під час створення локального псевдоніма для існуючого символу використовуйте формат існуючого ідентифікатора. Локальний псевдонім має відповідати існуючому імені та формату джерела. Для змінних використовуйте const для локальних псевдонімів, а для полів класу використовуйте атрибут readonly.

```js
const {BrewStateEnum} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

## 6 Система типів

### 6.1 Вивід типу (type inference)

Код може спиратися на виведення типів, реалізоване компілятором TypeScript, для всіх виразів типів (змінних, полів, типів повернення тощо).

```js
const x = 15; // Type inferred.
```

Пропустіть анотації типів для тривіально виведених типів: змінних або параметрів, ініціалізованих рядком, числом, логічним значенням, літералом RegExp або новим виразом.

Не потрібно так робити:

```js
const x: boolean = true; // Bad: 'boolean' here does not aid readability
const x: Set<string> = new Set(); // Bad: 'Set' is trivially inferred from the initialization
```

Явне визначення типів може знадобитися для запобігання виведенню параметрів універсального типу як `unknown`. Наприклад, ініціалізація універсальних типів без значень (наприклад, порожні `масиви`, `об'єкти`, `Map` або `Set`).

```js
const x = new Set<string>();
```

Для складніших виразів анотації типів можуть допомогти з читабельністю програми:

```js
// Можемо визначити тип 'value' з першого погляду.
const value: string[] = await rpc.getSomeValue().transform();
```

Чи потрібна анотація, вирішує спеціаліст із перевірки коду.

#### 6.1.1 Повертаємий тип

Чи включати анотації типів повернення для функцій та методів, залежить від автора коду. Рецензенти можуть запитувати анотації для уточнення складних типів повернення, які важко зрозуміти. Проєкти можуть мати локальну політику, яка завжди вимагає типів, що повертаються, але це не є загальною вимогою стилю TypeScript.

Явне введення неявних повернених значень функцій та методів має дві переваги:

- Більш точна документація на користь читачів коду.
- Швидше виявляти потенційні помилки типу в майбутньому, якщо будуть зміни коду, які змінять тип повернення функції.

### 6.2 Undefined та null

TypeScript підтримує типи `undefined` та `null`. Типи, що допускають значення `null`, можна побудувати як тип об'єднання `string|null`, аналогічно з `undefined`. Спеціального синтаксису для об'єднань `undefined` та `null` немає.

Код TypeScript може використовувати undefined або null для позначення відсутності значення, немає загальних рекомендацій щодо переваги одного з них над іншим. Багато JavaScript API використовують undefined (наприклад, Map.get), хоча багато DOM та інших API використовують null (наприклад, Element.getAttribute), тому відповідне значення відсутності залежить від контексту.

#### 6.2.1 Псевдоніми типів, що допускають nullable/undefined

Псевдоніми типів не повинні містити `|null` або `|undefined` у типі об'єднання. Псевдоніми, що допускають значення null, зазвичай вказують на те, що значення null передаються через забагато рівнів програми, і це приховує джерело початкової проблеми, яка призвела до значення null. Вони також роблять незрозумілим, коли певні значення в класі чи інтерфейсі можуть бути відсутніми.

Натомість, код повинен додавати `|null` або `|undefined` лише тоді, коли псевдонім фактично використовується. Код повинен обробляти значення null близько до місця їх виникнення, використовуючи вищезазначені методи.

```js
type CoffeeResponse = Latte|Americano;

class CoffeeService {
  getLatte(): CoffeeResponse|undefined { ... };
}
```

#### 6.2.2 Віддати перевагу optional над |undefined

TypeScript підтримує спеціальну конструкцію для необов'язкових параметрів і полів, використовуючи `?`:

```js
interface CoffeeOrder {
  sugarCubes: number;
  milk?: Whole|LowFat|HalfHalf;
}

function pourCoffee(volume?: Milliliter) { ... }
```

Необов'язкові параметри неявно включають `|undefined` у свій тип. Однак вони відрізняються тим, що їх можна пропустити під час побудови значення або виклику методу.

Використовуйте optional поля (на інтерфейсах або класах) та параметри, а не тип `|undefined`.

Для класів бажано взагалі уникати цього шаблону та ініціалізувати якомога більше полів.

### 6.3 Використовуйте структурні типи

Система типів TypeScript є структурною, а не номінальною. Тобто, значення відповідає типу, якщо воно має принаймні всі властивості, необхідні для цього типу, і типи властивостей рекурсивно збігаються.

Під час надання структурної реалізації, явно вказуйте тип під час оголошення символу (це дозволяє точнішу перевірку типів та звітування про помилки).

```js
const foo: Foo = {
  a: 123,
  b: "abc",
};
```

Використовуйте інтерфейси для визначення структурних типів, а не класи.

```js
interface Foo {
  a: number;
  b: string;
}

const foo: Foo = {
  a: 123,
  b: "abc",
};
```

### 6.4 Надавайте перевагу інтерфейсам над псевдонімами літералів типів

TypeScript підтримує псевдоніми типів для найменування виразів типу. Це можна використовувати для найменування примітивів, об'єднань, кортежів та будь-яких інших типів.

Однак, під час оголошення типів для об'єктів, використовуйте інтерфейси замість псевдоніма типу для виразу літерала об'єкта.

Правильно:

```js
interface User {
  firstName: string;
  lastName: string;
}
```

Не правильно:

```js
type User = {
  firstName: string,
  lastName: string,
};
```

### 6.5 `Array<T>` або `T[]`

Для простих типів (що містять лише буквено-цифрові символи та крапку) використовуйте синтаксичний цукор для масивів `T[]` або `readonly T[]`, а не довшу форму `Array<T>` або `ReadonlyArray<T>`. Так само для Для багатовимірних масивів простих типів.

Для чогось складнішого використовуйте довшу форму `Array<T>`.

Ці правила застосовуються на кожному рівні вкладеності, тобто простий `T[]`, вкладений у складніший тип, все одно буде записуватися як `T[]`, використовуючи синтаксичний цукор.

```js
let a: string[];
let b: readonly string[];
let c: ns.MyObj[];
let d: string[][];
let e: Array<{n: number, s: string}>;
let f: Array<string|number>;
let g: ReadonlyArray<string|number>;
let h: InjectionToken<string[]>;
let i: ReadonlyArray<string[]>;
let j: Array<readonly string[]>;
```
